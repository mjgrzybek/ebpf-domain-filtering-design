#include <linux/if_ether.h>
#include <linux/ip.h>

#include <linux/types.h>
#include <linux/bpf.h>

BPF_RINGBUF_OUTPUT(output, 1<<4); 
 
enum decision {
    DETECTED, // connection detected but prevention mode is not enabled
    ALLOWED,
    BLOCKED,
};

// Structure to hold data that will be sent to user space
struct event {
    u32 ip_src;
    enum decision decision;
};

// naive implementation, array based, O(n) search complexity
// in real world, we would use a hash map with O(1) search complexity
bool static is_ip_allowed(u32 ip) {
    u32 allowedIps[] = { 
        // dynamically generated by the Engine, based on user-defined rule content
    };

    u32 allowedIpsLen = sizeof(allowedIps) / sizeof(allowedIps[0]);

    for (u32 i = 0; i < allowedIpsLen; i++) {
        if (allowedIps[i] == ip) {
            return true;
        }
    }

    return false;
}


int filter_ip(struct xdp_md *ctx) {
    void *data = (void *)(long)ctx->data;
    void *data_end = (void *)(long)ctx->data_end;

    struct iphdr *iph;
    
    if (data_end >= data + sizeof(struct ethhdr)) {
        iph = data + sizeof(struct ethhdr);
    } else {
        return XDP_ABORTED;
    }
    
    bool is_allowed = is_ip_allowed(iph->saddr);

    struct event event = {
        .ip_src = iph->saddr,
        .decision = is_allowed ? ALLOWED : BLOCKED,
    };

    output.ringbuf_output(&event, sizeof(event), 0); 

    return is_allowed ? XDP_PASS : XDP_DROP;
}
